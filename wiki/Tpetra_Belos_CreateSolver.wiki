#summary Create Belos iterative linear solver for Tpetra sparse linear system

= Introduction =

The Belos package implements several different iterative linear solver algorithms.  These include standard algorithms like CG, GMRES, Transpose-Free QMR, and LSQR, as well as algorithms specifically designed to accelerate solution of systems with multiple right-hand sides.

This example shows how to create and use a Belos GMRES solver with a preconditioner.

= Code example = 

{{{
// Solve the linear system(s) AX=B, using GMRES with the preconditioner M.
//
// B: right-hand side(s) of the linear system(s) AX=B.
// X: On input: initial guess(es) for solving AX=B.  On output: solution vector(s).
// A: the sparse matrix (or operator; it need not be a sparse matrix).
// M: if not null, the (right) preconditioner for A.
//
// In this example, MV is a specialization of Tpetra::MultiVector, 
// and OP is a specialization of Tpetra::Operator (the parent class 
// of Tpetra::CrsMatrix, Ifpack2::Preconditioner, and other classes 
// as well).
template<class MV, class OP>
void
solve (MV& X, const MV& B, const OP& A, Teuchos::RCP<OP> M) 
{
  using Teuchos::ParameterList;
  using Teuchos::parameterList;
  using Teuchos::RCP; 
  using Teuchos::rcp;
  using Teuchos::rcpFromRef; // Make a "weak" RCP from a reference.

  // Make an empty new parameter list.
  RCP<ParameterList> solverParams = parameterList();

  // Set some GMRES parameters.
  //
  // "Num Blocks" = Maximum number of Krylov vectors to store.  This
  // is also the restart length.  "Block" here refers to the ability
  // of this particular solver (and many other Belos solvers) to solve
  // multiple linear systems at a time, even though we may only be
  // solving one linear system in this example.
  //
  // "Maximum Iterations": Maximum total number of iterations,
  // including restarts.
  //
  // "Convergence Tolerance": By default, this is the relative
  // residual 2-norm, although you can change the meaning of the
  // convergence tolerance using other parameters.
  solverParams->set ("Num Blocks", 40);
  solverParams->set ("Maximum Iterations", 400);
  solverParams->set ("Convergence Tolerance", 1.0e-8);

  // Create the GMRES solver using a "factory" and 
  // the list of solver parameters created above.
  Belos::SolverFactory<Scalar, MV, OP> factory;
  RCP<Belos::SolverManager<Scalar, MV, OP> > solver = 
    factory.create ("GMRES", solverParams);

  // Create a LinearProblem struct with the problem to solve.
  // A, X, B, and M are passed by (smart) pointer, not copied.
  typedef Belos::LinearProblem<Scalar, MV, OP> problem_type;
  RCP<problem_type> problem = 
    rcp (new problem_type (rcpFromRef (A), rcpFromRef (X), rcpFromRef (B)));
  // You don't have to call this if you don't have a preconditioner.
  // If M is null, then Belos won't use a (right) preconditioner.
  problem->setRightPrec (M);

  // Tell the solver what problem you want to solve.
  solver->setProblem (problem);

  // Attempt to solve the linear system.  result == Belos::Converged 
  // means that it was solved to the desired tolerance.  This call 
  // overwrites X with the computed approximate solution.
  Belos::ReturnType result = solver->solve();

  // Ask the solver how many iterations the last solve() took.
  const int numIters = solver->getNumIters();
}
}}}